Memory management is the task of managing the main memory (RAM) to accommodate multiple processes efficiently. It provides abstraction, protection, and sharing while maximizing memory utilization.

#### Logical vs. Physical Address Space

A crucial concept is the separation between the address space generated by the CPU and the one seen by the physical memory.

- **Logical Address**: An address generated by the CPU, also known as a **virtual address**. It's the address from the program's perspective.
- **Physical Address**: The actual address in the main memory (RAM) that the memory controller sees.

The mapping from logical to physical addresses is handled by a hardware device called the **Memory Management Unit (MMU)**.

**MMU Operation Block Diagram**

![[mermaid-diagram-2025-07-17-015936.png]]

---

### Paging

Paging is the primary memory management technique used in most modern operating systems. It avoids the problems of fragmentation by dividing memory into fixed-size blocks.

- **Frames**: Physical memory is divided into fixed-size blocks called frames.
- **Pages**: A process's logical memory is divided into blocks of the same size called pages.
- **Mechanism**: When a process is to be executed, its pages can be loaded into any available frames in physical memory. These frames do not need to be contiguous.
#### Address Translation in Paging

The MMU translates a logical address into a physical address using a **page table**.

1. The logical address is split into two parts:
    - **Page number (p)**: Used as an index into the page table.
    - **Page offset (d)**: The location within the page.
2. The page table contains the base address of each page (i.e., the **frame number (f)**).
3. The physical address is formed by combining the frame number `f` with the page offset `d`.

**Paging Example**

- **Page Size**: 4 KB (4096 bytes)
- **Logical Address**: 5000
- **Calculation**:
    - **Page number (p)** = `5000 / 4096` = **1**
    - **Page offset (d)** = `5000 % 4096` = **804**
- The MMU uses `p=1` as an index into the process's page table. Let's say the page table shows that page 1 is in frame 6.
- **Physical Address** = `(Frame number * Page Size) + Offset` = `(6 * 4096) + 804` = `24576 + 804` = **25380**.

**Paging Hardware Block Diagram**

![[mermaid-diagram-2025-07-17-020129.png]]


---

### Virtual Memory

Virtual memory is a technique that allows the execution of processes that may not be completely held in physical memory. This allows programs to be larger than the physical RAM available.

- **Demand Paging**: The most common implementation of virtual memory. Pages are loaded from the disk into memory only when they are needed ("on demand").
- **Page Fault**: When a process tries to access a page that is not currently in a memory frame, the MMU generates a trap to the operating system called a **page fault**.

#### Handling a Page Fault

The OS performs the following steps to handle the fault:

1. Check if the logical memory access is valid.
2. Find a free frame in physical memory. (If there are no free frames, a page replacement algorithm is run).
3. Schedule a disk operation to read the required page from disk into the free frame.
4. Update the process's page table to reflect that the page is now in memory.
5. Restart the instruction that caused the page fault.

**Page Fault Handling Diagram**

![[mermaid-diagram-2025-07-17-020445.png]]
---

### Page Replacement Algorithms

When a page fault occurs and there are no free frames, an existing page must be swapped out to disk to make room. The algorithm that chooses the "victim" page is a page replacement algorithm.

**Example Scenario**

- **Reference String** (sequence of page accesses): `7, 0, 1, 2, 0, 3, 0, 4, 2, 3, 0, 3, 2`
- **Number of available frames**: 3

#### 1. FIFO (First-In, First-Out)

The OS replaces the page that has been in memory the longest.

|Reference|Page 1|Page 2|Page 3|Fault?|
|---|---|---|---|---|
|7|**7**|||Yes|
|0|7|**0**||Yes|
|1|7|0|**1**|Yes|
|2|**2**|0|1|Yes|
|0|2|0|1|No|
|3|2|**3**|1|Yes|
|0|2|3|**0**|Yes|
|4|**4**|3|0|Yes|
|2|4|**2**|0|Yes|
|3|4|2|**3**|Yes|
|0|**0**|2|3|Yes|
|3|0|2|3|No|
|2|0|2|3|No|
|**Total Page Faults: 10**|||||

#### 2. LRU (Least Recently Used)

The OS replaces the page that has not been used for the longest period of time.

|Reference|Page 1|Page 2|Page 3|Fault?|
|---|---|---|---|---|
|7|**7**|||Yes|
|0|7|**0**||Yes|
|1|7|0|**1**|Yes|
|2|**2**|0|1|Yes|
|0|2|**0**|1|No|
|3|2|0|**3**|Yes|
|0|2|**0**|3|No|
|4|**4**|0|3|Yes|
|2|4|0|**2**|Yes|
|3|**3**|0|2|Yes|
|0|3|**0**|2|No|
|3|**3**|0|2|No|
|2|3|0|**2**|No|
|**Total Page Faults: 8**|||||

As seen in the example, LRU generally performs better than FIFO. The **Optimal (OPT)** algorithm provides the best possible performance but is unimplementable as it requires knowledge of the future.

---
### Summary of Differences

|Feature|Logical Memory|Virtual Memory|
|---|---|---|
|**What it is**|An **abstract view** of memory|A memory management **technique**|
|**Primary Goal**|To provide each process with a private and protected address space|To allow a program to be larger than the available physical RAM|
|**Key Mechanism**|Address translation via the MMU|Demand paging and handling page faults|
|**Relationship**|Logical memory is a **prerequisite** for virtual memory. You cannot have virtual memory without the concept of a logical address space.||

---
