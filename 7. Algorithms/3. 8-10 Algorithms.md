## 8. Two Pointers Technique ðŸ‘‰ðŸ‘ˆ

This is a **pattern**, not a single algorithm. It's an extremely common and efficient technique for problems involving **sorted arrays** or lists where you need to find a pair or a set of elements that satisfy a certain condition. It avoids slower nested loops by intelligently traversing the data.

### The Core Idea

You initialize two pointers, typically one at the very beginning (`left`) and one at the very end (`right`) of a sorted array. You then move them towards each other based on the sum or property of the elements they point to, converging on the solution in a single pass.

### Visual Diagram & Trace

**Problem:** In the sorted array `[2, 7, 11, 15]`, find two numbers that add up to `target = 9`.

1. **Initial State:**
    
    ```
    [ 2,  7,  11,  15 ]
      ^           ^
      L           R
    ```

    - `nums[L] + nums[R]` = `2 + 15` = `17`.
    - `17 > 9` (Sum is too big). To make the sum smaller, we must move the right pointer left.
    - `R--`.

2. **Step 2:**
    
    ```
    [ 2,  7,  11,  15 ]
      ^       ^
      L       R
    ```
    
    - `nums[L] + nums[R]` = `2 + 11` = `13`.
    - `13 > 9` (Still too big). Move the right pointer left again.
    - `R--`.

3. **Step 3:**
    
    ```
    [ 2,  7,  11,  15 ]
      ^   ^
      L   R
    ```
    
    - `nums[L] + nums[R]` = `2 + 7` = `9`.
    - `9 == 9`. **Match found!** Return the indices.


### Complexities

- **Time Complexity:** O(N) (Best, Average, and Worst). The pointers together make a single pass through the array.
- **Space Complexity:** O(1). It only uses a few variables for the pointers.

### Core LeetCode Problem & Solution

- **Problem:** [167. Two Sum II - Input Array Is Sorted](https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/)
- **Description:** Given a 1-indexed sorted array of integers, find two numbers that add up to a specific target.

#### Python Code Solution

Python

```python
def twoSum(numbers: list[int], target: int) -> list[int]:
    """
    Finds two numbers in a sorted array that add up to the target.
    """
    left, right = 0, len(numbers) - 1

    while left < right:
        current_sum = numbers[left] + numbers[right]

        if current_sum == target:
            # LeetCode asks for 1-based indexing, so we add 1.
            return [left + 1, right + 1]
        elif current_sum < target:
            # Sum is too small, need a larger value. Move left pointer right.
            left += 1
        else: # current_sum > target
            # Sum is too big, need a smaller value. Move right pointer left.
            right -= 1
```

### LeetCode Variants

1. **[15. 3Sum](https://leetcode.com/problems/3sum/)**
    
    - **Variation:** Find all unique triplets `(a, b, c)` that sum to zero.
    - **Logic Change:** First, sort the array. Then, loop through the array with a pointer `i`. For each `nums[i]`, run the Two Pointers technique on the rest of the array to find two numbers that sum to `-nums[i]`.
    - **Brief Explanation:** The problem `a + b + c = 0` becomes `b + c = -a`. The outer loop fixes `a`, and the two pointers find `b` and `c`. You must add logic to skip duplicate values to ensure unique triplets.

2. **[11. Container With Most Water](https://leetcode.com/problems/container-with-most-water/)**
    
    - **Variation:** Find two lines that, together with the x-axis, form a container that holds the most water.
    - **Logic Change:** The area is `width * min(height[L], height[R])`. The width is always decreasing as pointers move inward. To have a chance at a larger area, you must try to increase the minimum height.
    - **Brief Explanation:** Start pointers at both ends. Calculate the area. To potentially find a larger area, you must discard the shorter of the two lines. So, if `height[L] < height[R]`, you move `L` right. Otherwise, you move `R` left.
        
---
## 9. Sliding Window Technique ðŸ–¼ï¸

This is another essential **pattern** for problems on arrays or strings. It involves maintaining a "window" (a sub-array or sub-string) and "sliding" it over the data. The window, defined by `start` and `end` pointers, can be of a fixed size or a dynamic size that grows and shrinks to satisfy a condition.

### The Core Idea

You expand the window by moving the `end` pointer to the right. When the window's state no longer meets the problem's criteria (e.g., it contains a duplicate character, or its sum exceeds a target), you shrink the window by moving the `start` pointer to the right until the condition is met again.

### Visual Diagram & Trace

**Problem:** Find the length of the longest substring without repeating characters in `s = "pwwkew"`.

1. **`end=0` (`'p'`)**: Window `['p']`. No repeats. Length = 1. `max_len=1`.
2. **`end=1` (`'w'`)**: Window `['p', 'w']`. No repeats. Length = 2. `max_len=2`.
3. **`end=2` (`'w'`)**: Window `['p', 'w', 'w']`. **Repeat found!**
    - Shrink from left: Remove `'p'`. Window `['w', 'w']`. Still a repeat.
    - Shrink from left: Remove `'w'`. Window `['w']`. No repeats. Length = 1.
4. **`end=3` (`'k'`)**: Window `['w', 'k']`. No repeats. Length = 2. `max_len=2`.
5. **`end=4` (`'e'`)**: Window `['w', 'k', 'e']`. No repeats. Length = 3. `max_len=3`.
6. **`end=5` (`'w'`)**: Window `['w', 'k', 'e', 'w']`. **Repeat found!**
    - Shrink from left: Remove `'w'`. Window `['k', 'e', 'w']`. No repeats. Length = 3.

Final `max_len` is **3**.
### Complexities

- **Time Complexity:** O(N). Each pointer (`start` and `end`) traverses the array only once.
- **Space Complexity:** O(K) where K is the number of unique elements in the window (e.g., size of the character set).

### Core LeetCode Problem & Solution

- **Problem:** [3. Longest Substring Without Repeating Characters](https://leetcode.com/problems/longest-substring-without-repeating-characters/)
- **Description:** Given a string `s`, find the length of the longest substring without repeating characters.

#### Python Code Solution

Python

```python
def lengthOfLongestSubstring(s: str) -> int:
    """
    Finds the length of the longest substring without repeating characters.
    """
    char_set = set() # A set to store characters in the current window
    left = 0         # The left pointer of the window
    max_length = 0

    # The right pointer of the window moves with the loop
    for right in range(len(s)):
        # If the character is already in our window, we must shrink the window
        # from the left until the duplicate is removed.
        while s[right] in char_set:
            char_set.remove(s[left])
            left += 1
        
        # Add the new character to our window's set (expanding the window)
        char_set.add(s[right])
        
        # Update the max length found so far
        max_length = max(max_length, right - left + 1)
        
    return max_length
```

### LeetCode Variants

1. **[209. Minimum Size Subarray Sum](https://leetcode.com/problems/minimum-size-subarray-sum/)**
    
    - **Variation:** Find the length of the _smallest_ contiguous subarray whose sum is `>=` a target.
    - **Logic Change:** The window condition is based on the sum of its elements.
    - **Brief Explanation:** Expand the window by adding `nums[right]` to a `current_sum`. While `current_sum >= target`, record the window's length (and check if it's the new minimum), then shrink the window by subtracting `nums[left]` from the sum and moving `left` forward.
    
2. **[76. Minimum Window Substring](https://leetcode.com/problems/minimum-window-substring/)**
    
    - **Variation:** Given two strings `s` and `t`, find the minimum window in `s` which contains all the characters of `t`.
    - **Logic Change:** Much more complex state tracking. You need two hash maps: one for the character counts required by `t`, and one for the character counts in your current window.
    - **Brief Explanation:** Expand the window until it contains all characters of `t` (checked by comparing the maps). Once you have a valid window, record its length and try to shrink it from the left as much as possible while keeping it valid.

---

## 10. Kadane's Algorithm

This is a brilliant and efficient dynamic programming approach to solve the "maximum subarray sum" problem. It answers the question: which contiguous part of this array has the largest possible sum?

### The Core Idea

The algorithm iterates through the array just once. At each step, it makes a simple decision for the element `x`:

1. Should I extend the "best subarray so far" by adding `x` to it?
2. Or is the previous subarray so bad (negative) that I'm better off starting a brand new subarray with just `x`?

It keeps track of the maximum sum ending at the current position (`current_max`) and the absolute maximum sum found anywhere in the array so far (`global_max`).

### Visual Diagram & Trace

Let's trace `[-2, 1, -3, 4, -1, 2, 1, -5, 4]`

|Element|`current_max` Logic|`current_max` Value|`global_max` Value|
|---|---|---|---|
|**-2**|Start new: `max(-2, -2)`|-2|-2|
|**1**|Extend: `max(1, -2 + 1)`|1|1|
|**-3**|Extend: `max(-3, 1 + -3)`|-2|1|
|**4**|Start new: `max(4, -2 + 4)`|4|4|
|**-1**|Extend: `max(-1, 4 + -1)`|3|4|
|**2**|Extend: `max(2, 3 + 2)`|5|5|
|**1**|Extend: `max(1, 5 + 1)`|6|6|
|**-5**|Extend: `max(-5, 6 + -5)`|1|6|
|**4**|Extend: `max(4, 1 + 4)`|5|6|

The final answer is `global_max = 6`, which corresponds to the subarray `[4, -1, 2, 1]`.

### Complexities

- **Time Complexity:** O(N) (Best, Average, and Worst) because it's a single pass through the array.
- **Space Complexity:** O(1) because it only uses a few variables to store state.

### Core LeetCode Problem & Solution

- **Problem:** [53. Maximum Subarray](https://leetcode.com/problems/maximum-subarray/)
- **Description:** Given an integer array `nums`, find the contiguous subarray with the largest sum and return its sum.

#### Python Code Solution

Python

```python
def maxSubArray(nums: list[int]) -> int:
    """
    Finds the maximum subarray sum using Kadane's Algorithm.
    """
    # Initialize both maxes with the first element of the array.
    # global_max stores the answer we will return.
    # current_max stores the max sum of a subarray ending at the current position.
    global_max = nums[0]
    current_max = nums[0]

    # Start iterating from the second element.
    for i in range(1, len(nums)):
        num = nums[i]
        # Decision: either extend the previous subarray or start a new one.
        current_max = max(num, current_max + num)
        
        # Update the global max if the current local max is greater.
        if current_max > global_max:
            global_max = current_max
            
    return global_max
```

### LeetCode Variants

1. **[918. Maximum Sum Circular Subarray](https://leetcode.com/problems/maximum-sum-circular-subarray/)**
    
    - **Variation:** The array can "wrap around". The max subarray could be `[..., end] + [start, ...]`.
    - **Logic Change:** The answer is either (A) the normal max subarray (non-wrapping case) or (B) the total sum of the array minus the minimum subarray (wrapping case). The minimum subarray is found by inverting the array's signs and running Kadane's.
    - **Brief Explanation:** You find the standard `max_sum` with Kadane's. You also find the `min_sum` (by finding the max sum of the inverted array). The circular max is `total_sum - min_sum`. The final answer is `max(max_sum, total_sum - min_sum)`. (Edge case: if all numbers are negative, the answer is just the standard `max_sum`).
        
2. **[152. Maximum Product Subarray](https://leetcode.com/problems/maximum-product-subarray/)**
    
    - **Variation:** Find the maximum _product_ instead of sum.
        
    - **Logic Change:** A large negative number can become a large positive number if multiplied by another negative number.
        
    - **Brief Explanation:** You must track both the `current_max_product` and `current_min_product` ending at the current position. The new max could be `current_num`, `current_num * old_max`, or `current_num * old_min`.